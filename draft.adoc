= Comparativa de tecnologías de servidor para servicios basados en websocket
Michel Maes Bermejo <m.maes@alumnos.urjc.es>
:toc:
:toc-title: Contenido
:doctype: book
:source-highlighter: rouge
:rouge-style: custom
:icons: font
:icon-set: fa
:pdf-stylesdir: resources/themes
:imagesdir: resources/images
:pdf-fontsdir: resources/fonts
:no title:

[abstract]
== Resumen

Página resumiendo el contenido de la memoria. Esta página se escribe cuando ya se
ha escrito toda la memoria.

== 1. Introducción y Motivación

Hoy en día, un desarrollador de software tiene múltiples herramientas (entre
lenguajes y librerías) para abordar cualquier proyecto que tenga entre manos.
Es una práctica común usar una tecnología concreta sobre la que sentimos predilección
o las que creemos que pueden resolver mejor nuestro problema. En ocasiones, nos
equivocamos en nuestra elección y descartamos opciones mucho más efectivas.

Este problema de desinformación puede abordarse mediante el estudio de las
distintas tecnologías que proponen una solución al mismo, pero dado que el
ámbito del desarrollo software es muy amplio, vamos a centrarnos en las
tecnologías de servidor para servicios basados en WebSockets.

Estas tecnologías proporcionan una comunicación en tiempo real con clientes
muy diversos (aplicaciones móviles, navegadores, otro servidores…). Un ejemplo
actual son los servicios de mensajería instantánea cómo WhatsApp o Telegram. Hoy
en día este tipo de aplicaciones tienen un impacto drástico en la vida diaria,
siendo casi una herramienta imprescindible, por lo que prevenir una caída de
servicio ante un alto número de clientes es fundamental.

.Crecimiento de WhatsApp en los últimos 4 años
image::./crecWhastApp.png[Crecimiento WhatsApp, pdfwidth=80%]

La motivación de este proyecto surge de la necesidad de comprender mejor estas
tecnologías y proporcionar argumentos sólidos que justifiquen el uso de una u
otra, dependiendo de las necesidades de nuestro proyecto y de los recursos de
los que dispongamos.

== 2. Objetivos

El objetivo principal de este proyecto será realizar una comparativa entre
distintas tecnologías que den solución a la comunicación en tiempo real mediante
el uso de WebSockets, dentro de una misma máquina (escalado vertical).

Con este fin, se implementará una aplicación de mensajería instantánea (que a
partir de ahora denominaremos simplemente Chat) para cada tecnología y un
cliente común capaz de probarlas y recoger distintas métricas, que serán el
factor determinante a la hora de realizar la comparativa.

Otro objetivo relevante del proyecto será su extensibilidad, de forma que
cualquier desarrollador pueda implementar su aplicación de chat, sumarla a la
comparativa y así contribuir al proyecto.

El proyecto base corresponde a Javier Mateos <<https://github.com/meji92>> que
realizó una comparativa entre las aplicaciones de Akka y Vert.x. Nuestro
proyecto pretende ser una continuación y expansión del anterior, concretamente:

- Implementar un cliente de pruebas que automatice el proceso de comparación
(obtención de métricas) y genere una un cliente web que muestre los resultados
de forma dinámica y permita almacenarlos.

- Re-escribir la aplicación de Vert.x a su versión más reciente.

- Incluir nuevas implementaciones con distintas tecnologías para ampliar la comparativa

== 3. Tecnologías, Herramientas y Metodologías

=== 3.1 Tecnologías

De la multitud de lenguajes de programación que existen válidos para afrontar el
desarrollo de un servidor basado en WebSocket nuestra primera opción ha sido
seleccionar Java, que dispone de múltiples librerías interesantes para abordar
el problema además de ser uno de os lenguajes de programación más extendidos,
populares y con una amplia comunidad, como demuestra el informe TIOBE (Ver __Figura 2__).
De forma adicional, se ha incluido también Node.js, tecnología muy popular en
los últimos años que promete ser ligera y eficiente.

.Indice Tiobe
image::./tiobe.png[tiobe]

<<<

==== 3.1.1 WebSockets

.Logo WebSocket
image::./websockets-logo.png[websocket, pdfwidth=40%]

RFC 6455 <<https://tools.ietf.org/html/rfc6455>> define WebSocket como un protocolo que proporciona un canal
de comunicación bidireccional y full-dúplex sobre un único socket TCP. Aunque
inicialmente estaba pensada para comunicaciones entre el navegador y el servidor
web, puede usarse también para aplicaciones cliente/servidor.

Por otro lado, W3C se encarga de normalizar la API<<https://www.w3.org/TR/2011/WD-websockets-20110929>> de WebSocket.
Define una interfaz para el navegador compuesta por 4 métodos que corresponder
a handlers para los diferentes eventos que maneja.

[source,javascript]
---------------------------------------------------------------------
var socket = new WebSocket('ws://example.com:9000/chat');
// Send new text
socket.send("Some text");
socket.onmessage = function(event) {
    var data = JSON.parse(event.data);
    // Use data
});
socket.onopen  = function(e){ console.log("WS Opened")};
socket.onclose = function(e){ console.log("WS Closed")};
---------------------------------------------------------------------

<<<

==== 3.1.2 Node.js
image::./node-logo.png[node, pdfwidth=40%]

Node.js<<https://nodejs.org/es/>> es un entorno de ejecución para JavaScript construido con el motor de JavaScript V8<<https://developers.google.com/v8/>> de Chrome. Está diseñado para construir aplicaciones en red escalables. Se caracteriza por sus operaciones E/S sin bloqueos y por su arquitectura orientada a eventos. Está pensado Tiene un diseño similar y está influenciado por sistemas como Event Machine de Ruby ó Twisted de Python.

La versión utilizada en este proyecto es la 6.9.1

[.underline]#Conceptos básicos de Node.js#

- *Arquitectura de eventos*: Node.js presenta un bucle de eventos como un entorno, no como una librería (soporte nativo). Dentro de este entorno de ejecución, cada conexión de un cliente tiene asignado un callback, y recibe una pequeña asignación de memoria dinámica (sin generar un nuevo hilo). Este bucle de eventos ejecuta de forma secuencial los callbacks hasta que no queda ninguno por atender.

- *Concurrencia*<<https://es.wikipedia.org/wiki/Node.js#Concurrencia>>: Node.js funciona con un modelo de evaluación de un único hilo de ejecución, usando entradas y salidas asíncronas las cuales pueden ejecutarse concurrentemente en un número de hasta cientos de miles sin incurrir en costos asociados al cambio de contexto.

- *Ejecución*: Node.js, al estar desarrollado a partir de V8, no interpreta el código JavaScript en tiempo real, sino que lo compila directamente  a código máquina.

La versión utilizada de Node.js para este proyecto es la 6.9.1, aunque existen versiones posteriores, estas contienen algunas incompatibilidades con algunas librerias.

<<<

===== 3.1.2.1 Express

Express<<http://expressjs.com/es/>> es una infraestructura de aplicaciones web para Node.js, que proporciona un conjunto de características para crear aplicaciones web de forma simple y flexible.

[source,javascript]
---------------------------------------------------------------------
var express = require('express');
var app = express();
// respond with "hello world" when a GET request is made to the homepage
app.get('/', function(req, res) {
  res.send('hello world');
});
---------------------------------------------------------------------

===== 3.1.2.2 WS

WS<<https://github.com/websockets/ws>> es una librería de Node.js que proporciona la funcinalidad necesaria para abrir una conexión WebSocket en Node.js, tanto cliente como servidor. Puede ser utilizada junto a Express para dotar una aplicación web de conexión WebSocket.

===== 3.1.3.3 Cluster

Cluster<<https://nodejs.org/api/cluster.html>><<https://www.npmjs.com/package/cluster>> es una librería que permite a Node.js aprovechar los distintos cores del sistema en el que se ejecuta, dado que por defecto, Node.js se ejecuta como un único thread.

Esta librería también facilita el balanceo de carga entre los distintos procesos, permitiéndoles compartir el puerto que escuchan y distribuyendo la carga mediante un algoritmo de Round Robin.

==== 3.1.4 AngularJS

.Logo AngularJS
image::./angularjs.png[angularjs, pdfwidth=40%]

AngularJS <<https://www.angularjs.org/>> <<https://es.wikipedia.org/wiki/AngularJS >>es un framework de JavaScript de código abierto desarrollado por Google. Nos permite desarrollar SPAs (Single Page Applications), que siguiendo el MVC (modelo-vista-controlador), facilitan la presentación y manipulación de los datos en el lado cliente (frontend), reduciendo la carga lógica del lado servidor (backend).

<<<

Entre sus características, destacamos:

- La extensión del html mediante etiquetas y sintaxis propia.

- Inyección de dependencias

- Una numerosa comunidad y una extensa documentación

La versión utilizada para este proyecto es la 1.4, aunque actualmente está disponible Angular 2, conocido simplemente con Angular<<https://angular.io/>>, una versión revulsiva y no retro compatible, que se apoya en Typescript, una extensión de JavaScript. No se ha utilizado esta nueva versión por la simplicidad que ofrecía AngularJS al no requerir dependencias o desplegado de la aplicación.

==== 3.1.5 Chart.js

.Logo Chart.js
image::./chartjs-logo.jpg[chartjs, pdfwidth=40%]

Chart.js<<http://www.chartjs.org/>> es una librería de JavaScript para el lado cliente que nos permite la generación de gráficas para nuestra aplicación.

Entre sus características destacamos:

- Gran variedad de gráficos

- Sencillez de uso y una amplia y detallada documentación

- No requiere de librerías adicionales

- Gráficos interactivos

Esta librería cuenta con una versión compatible con Angular <<http://jtblin.github.io/angular-chart.js/>> que será la utilizada en este proyecto.

<<<

==== 3.1.3 Java

.Logo Java
image::./java-logo.png[java, pdfwidth=40%]

Java es un lenguaje de programación de propósito general, concurrente y orientado
a objetos. Su sintaxis deriva en gran medida de C y C++. Uno de los principales
atractivos de Java es su máquina virtual (JVM) que nos permite ejecutar nuestro
código Java en cualquier dispositivo, independientemente de la arquitectura.
Las tecnologías basadas en Java seleccionadas para la comparativa son explicadas
a continuación.

<<<

===== 3.1.3.1 Vert.x

.Logo Vertx
image::./vertx-logo.png[vertx, pdfwidth=40%]

Vert.x es un toolkit de Java que permite construir aplicaciones reactivas.
Se autodenomina dirigido por eventos y no bloqueante, está inspirado en Node.js.

La versión utilizada en el proyecto es la 3.3.

[.underline]#Conceptos básicos de Vert.x#

* **Verticle** <<http://vertx.io/docs/vertx-core/java/#verticles>>: modelo de
concurrencia que propone Vertx. Un Verticle es una clase que se comporta como
un actor<<https://en.wikipedia.org/wiki/Actor_model>>, cuyo comportamiento está
orientado a enviar/recibir mensajes. Para facilitar el desarrollo, Vertx asegura
que el código de un verticle nunca va a ser ejecutado por más de un thread a la vez.

* **EventBus**: es uno de sus principales recursos que le da su carácter reactivo.
Consiste en un bus transversal a la aplicación que permite la comunicación entre
los verticles de distintas formas<<http://vertx.io/docs/apidocs/io/vertx/core/eventbus/EventBus.html>>:

* **Publicar-Subscribir**: Diversos verticles se subscriben a un determinado
topic proporcionando un handler que opere con la respuesta. Tras esto, basta
con publicar un mensaje bajo ese topic para que todos los componentes subscritos
lo reciban.

* **Punto a punto**: Al igual que el anterior, envía un mensaje bajo un topic,
pero en este caso, solo a uno de los subscriptores, elegido mediante un algoritmo
de round-robin no estricto.

* **Petición-Respuesta**: Similar al anterior, con la única diferencia que se
proporciona un handler para una posible respuesta.

* **Context** <<https://github.com/vietj/vertx-materials/blob/master/src/main/asciidoc/Demystifying_the_event_loop.adoc>>: se encarga de controlar un ámbito concreto de la aplicación, además del orden en el que los callbacks/handlers son ejecutados. Vertx dispone de 3 tipos diferentes de contexts:
** Event-loop: ejecuta los handlers de forma que un mismo handler es ejecutado únicamente en un Thread y este no debe ser bloqueante de ninguna manera (uso de herramientas de bloqueo condicional, llamadas a bases de datos, ejecuciones del sistema largas, etc…). Este modelo no es dependiente la sincronización y dota a Vertx, junto al EventBus de su reactividad, además de su carácter no bloqueante. Es el context usado por defecto.
** Worker: contexto ligado a los verticles, que siguen asegurando que se ejecutan en un solo Thread, pero permiten su bloqueo.
** Multi-Thread Worker: Permite la ejecución de un verticle en diferentes threads, de forma que pueda realizar las tareas de forma concurrente, delegando en el desarrollador la responsabilidad de asegurar la concurrencia y sincronización.

Además de los recursos mencionados, cuenta con una extensa API que abarca desde múltiples herramientas de testing hasta servidores y clientes de TCP/SSL, HTTP/HTTPS y WebSockets, cobrando estos últimos especial importancia de cara al desarrollo de la aplicación.

<<<

===== 3.1.3.2 Akka

.Logo Akka
image::./akka-logo.png[Akka, pdfwidth=40%]

Akka es otro toolkit para crear aplicaciones concurrentes y distribuidas. También se ejecuta sobre la JVM. Se puede utilizar con Java y Scala, lenguaje con el que está escrito y del que su implementación de los actores forma parte de la librería estándar desde la versión 2,10. Otras de sus características son:

- **Tolerancia a fallos**: Akka adopta el modelo de “let it crash” que ha resultado un gran éxito en la industria de la telecomunicación.

- **Transparencia de localización**: todo en Akka está diseñado para trabajar en un entorno distribuido: todas las comunicaciones son mediante paso de mensajes y todo es asíncrono

- **Persistencia**: Los mensajes recibidos por el actor pueden conservarse y ser reproducidos al iniciar o reiniciar el actor, por lo que se puede conservar el estado de los actores después de un fallo o al migrarlos a otro nodo.

La versión utilizada de Akka durante este proyecto es la 2.4-M2, aunque actualmente ya existe la versión 2.4.0 estable.

La aplicación de Akka hace uso de Play Framework<<https://www.playframework.com/>> un framework web open source, que da soporte web a la aplicación y proporciona la comunicación mediante WebSockets.

[.underline]#Conceptos básicos de Akka#

- **Actores**: Los actores son objetos que poseen un estado y un comportamiento. Se comunican entre ellos exclusivamente enviando mensajes que se encolan en el mailbox del actor de destino. Los actores se organizan jerárquicamente. Un actor encargado de realizar una tarea, puede dividir esa tarea en otras sub-tareas y enviárselas a unos actores hijos a los que supervisará.

- **Actor System**: Es el encargado de ejecutar, crear y borrar actores además de otros fines como la configuración o el logging. Varios actor systems con diferentes configuraciones puede coexistir en la misma JVM sin problemas, aunque al ser una estructura pesada que puede manejar de 1..N threads, se recomienda crear una por aplicación.

Para crear los actores, usaremos el siguiente método:

[source,java]
---------------------------------------------------------------------
Akka.system().actorOf(Props.create(ChatManager.class), "ChatManager");
---------------------------------------------------------------------

En este caso el actorSystem es devuelto por Akka.system(). Se invoca así debido a que es el actorSystem que crea PlayFramework por defecto. Pasamos como parámetros la función Props.create con el nombre de la clase y el nombre que le asignamos al actor. Props es un objeto de configuración usado para crear los actores. Es inmutable, por lo tanto es thread-safe y se puede compartir perfectamente.

Para eliminar un actor no necesitaremos llamar al actorSystem. Solo tendremos que enviar al actor una poisonPill y el mismo se eliminará. El propio actor también puede enviarse a si mismo esa poisonPill.

[source,java]
---------------------------------------------------------------------
self().tell(PoisonPill.getInstance(), self());
---------------------------------------------------------------------

- **Actor Reference**: Es un objeto que representa al actor en el exterior. Estos objetos pueden enviarse sin ninguna restricción y permiten enviar mensajes al actor con total transparencia, sin necesidad de actualizar las referencias a pesar de enviarse a otros hosts. Además evitan que desde el exterior pueda conocerse el estado del actor a no ser que este lo publique.

- **Actor Path**: Como los actores son creados en una estricta estructura jerárquica, existe una única secuencia de nombres de actores dados siguiendo recursivamente los links entre actores padres e hijos hasta el actorSystem. Esta secuencia similar a las rutas de un sistema de ficheros, por ello es conocida como actor Path.

La diferencia entre un actor path y una ActorReference es que el segundo tiene el mismo ciclo de vida que el actor. Si el actor se destruye su actor reference también, sin embargo un actor path puede existir perfectamente

<<<

===== 3.1.2.3 Spring Boot

.Logo Spring
image::./springboot-logo.png[spring, pdfwidth=40%]

Spring Boot<<http://projects.spring.io/spring-boot/>> comprende un módulo de Spring<<https://spring.io/>> (un framework para el desarrollo de aplicaciones web) que provee de todo lo necesario para crear una aplicación con un mínimo de configuración lista para lanzar. Spring Boot proporciona:

- Una experiencia de iniciación muy rápida

- Prototipos extensibles para la mayoría de problemas que podamos tener

- Características no funcionales comunes a la mayoría de proyectos (servidores integrados, seguridad, métricas, comprobaciones de estado, configuración externalizada).

Además, cuenta con el Sistema de Inversión de Control de Spring<<https://es.wikipedia.org/wiki/Spring_Framework#Contenedor_de_Inversi.C3.B3n_de_Control_.28inyecci.C3.B3n_de_dependencia.29>><<https://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html>>, que permite la configuración de los componentes de la aplicación, mientras que la administración del ciclo de vida de los objetos se lleva a cabo a través de la inyección de dependencias<<https://es.wikipedia.org/wiki/Inyecci%C3%B3n_de_dependencias>> (que a su vez es una forma de inversión de control).

La versión utilizada de Spring para este proyecto es la 1.4.3

[source,java]
---------------------------------------------------------------------
import org.springframework.boot.*;
import org.springframework.boot.autoconfigure.*;
import org.springframework.web.bind.annotation.*;

@RestController
@SpringBootApplication
public class Example {

	@RequestMapping("/")
	String home() {
		return "Hello World!";
	}

	public static void main(String[] args) throws Exception {
		SpringApplication.run(Example.class, args);
	}

}
---------------------------------------------------------------------

<<<

=== 3.2 Herramientas

==== 3.2.1 Control de versiones

.Logo Git
image::./git-logo.png[git, pdfwidth=30%]

Git <<https://git-scm.com/>> es un software de control de versiones diseñado por Linus Torvalds, pensando en la eficiencia y la confiabilidad del mantenimiento de versiones de aplicaciones cuando éstas tienen un gran número de archivos de código fuente.

Para el desarrollo de este proyecto hemos usado GitHub<<https://github.com>>, una plataforma de desarrollo colaborativa para alojar proyectos Git.

A pesar de su integración con diversos entornos de desarrollo, debido a la estructura del proyecto (un solo repositorio) hemos usado su versión por terminal.

<<<

==== 3.2.2 Gestores de dependencias

Debido a la pluralidad de tecnologías, hemos utilizado distintos gestores de dependencias:

===== 3.2.2.1 Maven

.Logo Maven
image::./maven-logo.png[maven, pdfwidth=40%]

Maven<<https://maven.apache.org/>> es una herramienta de software para la gestión y construcción de proyectos Java creada por Jason van Zyl. Hace uso de un POM (Project Object Model), un archivo XML que describe las dependencias y permite añadir opciones de ejecución, test y desplegamiento de la aplicación.

Se ha utilizado para configurar los proyectos en Vert.x y Spring Boot.

===== 3.2.2.2 SBT

.Logo SBT
image::./sbt-logo.png[sbt, pdfwidth=30%]

SBT<<http://www.scala-sbt.org/>> es una herramienta de software para construcción de proyectos en Scala y estándar para contruir aplicaciones en Play Framework, similar a Maven o Ant (propios de Java). Entre sus características, permite el uso conjunto de Java y Scala en el mismo proyecto. Su archivo de configuración es un.stb, que dispone dispone de sintaxis propia.

Se ha utilizado para configurar el proyecto de Akka.

<<<

===== 3.2.2.3 NPM

.Logo NPM
image::./npm-logo.png[npm, pdfwidth=30%]

Npm<<https://www.npmjs.com/>> es una herramienta software para la gestión y construcción de proyectos en Node.js creado por Isaac Z. Schlueter. Al igual que Maven, permite declarar las dependencias y distintas opciones de ejecución, desplegamiento y pruebas. Para ello hace uso de un archivo JSON llamado package.json.

Es utilizado en las aplicaciones de Node.js.


<<<

====  3.2.3 Entornos de desarrollo

Al contar con diferentes lenguajes, se han utilizado distintos entornos de desarrollo:

===== 3.2.3.1 Atom

.Logo Atom
image::./atom-logo.jpg[atom, pdfwidth=60%]

Atom<<https://atom.io/>> es un editor de texto sencillo, ligero y extensible creado por Github. Cuenta con una gran librería de paquetes aportados por la comunidad para facilitar el desarrollo software. Por defecto, no cuenta con ningún tipo de compilador o intérprete.

Se ha utilizado de forma conjunta con una terminal para el desarrollo de las aplicaciones en Node.js

===== 3.2.3.2 NetBeans

.Logo NetBeans
image::./netbeans-logo.jpg[netbeans, pdfwidth=60%]

NetBeans<<https://netbeans.org/>> es un entorno de desarrollo integrado libre, centrado sobre todo en el lenguaje Java. Ofrece una interfaz completa para el desarrollo de proyectos java, desde la documentación de las librerías hasta el lanzamiento de la aplicación o la monitorización de pruebas.

NetBeans permite además incluir plugins para mejorar el desarrollo. Para este proyecto se ha usado el plugin para PlayFramework <<http://plugins.netbeans.org/plugin/61050/pleasure-play-framework-plugin>> para el desarrollo de la aplicación en Akka.

Se ha utilizado para el desarrollo de las aplicaciones en Vert.x y Akka.

===== 3.2.3.3 Spring Tool Suite

.Logo Spring Tool Suite
image::./sts-logo.png[sts, pdfwidth=20%]

Sprint Tool Suit (STS)<<https://spring.io/tools>> es un entorno de desarrollo basado en Eclipse<<https://eclipse.org/>> y adaptado a proyectos que utilizan el framework Spring, facilitando su desarrollo, construcción y despliegue.

Se ha utilizado para el desarrollo de las aplicaciones en Spring.

<<<

=== 3.3 Metodología

El modelo de desarrollo de este proyecto se ha llevado a cabo a través de TDD<<https://es.wikipedia.org/wiki/Desarrollo_guiado_por_pruebas>>(Test-driven Development, o en español, desarrollo guiado por pruebas), una práctica de igeniría del software cuya principal idea es hacer que los requistos sean traducidos a pruebas.

Las razones que han llevado a utilizar un ciclo de desarrollo conducido por pruebas son:

La naturaleza intrínseca del proyecto, distintas aplicaciones cuyo funcionamiento debe ser el mismo y por tanto comparten requisitos.

La herencia de un proyecto, que proporcionaba dichas pruebas de integración necesarias para validad cualquier aplicación.

.Ciclo de desarrollo conducido por pruebas
image::./tdd.png[tdd, pdfwidth=90%]

Por lo tanto, para cada aplicación que implementásemos, debíamos desarrollarla de acuerdo a las pruebas, de forma que una vez las pasasen, solo debíamos refactorizar la aplicación para mejorar su rendimiento y mantenibilidad.

== 4. Descripción informática

En este apartado se abordará la construcción del proyecto. Todo el proyecto (que incluye tanto las aplicaciones de chat como el cliente de pruebas, pueden encontrarse en el siguiente repositorio de GitHub:

https://github.com/Maes95/TFG-WebChat/tree/v2.1

El proyecto realizado consta de 7 aplicaciones de chat y un cliente de pruebas. Las aplicaciones construidas y que entran a formar parte de la comparativa son:

- Node.js
- Node.js con librería de clúster
- Akka
- Vert.x
- Vert.x sin EventBus
- SpringBoot con servidor Tomcat
- SpringBoot con servidor Jetty

La comparativa tomará en cuenta únicamente la escalabilidad vertical, por lo que todas las aplicaciones se desarrollaran para funcionar como un único nodo en una sola máquina.

=== 4.1. Requisitos

Como se ha mencionado anteriormente, este proyecto es la continuación de uno anterior, del que se ha heredado un cliente de chat que funciona como prueba de integración. Los requisitos, por lo tanto, quedan condicionados al funcionamiento de dicho cliente. Cada aplicación se construirá siguiendo los mismos requisitos.

Distinguiremos entre requisitos funcionales y no funcionales:

==== 4.1.1 Requisitos funcionales

Los requisitos funcionales fueron detallados como documentación y publicados como una página en una wiki de GitHub para que cualquier desarrollador pudiera incluir su propia aplicación. Su versión en inglés puede ser encontrada en el siguiente enlace https://github.com/Maes95/TFG-WebChat/wiki/How-to-Build-an-Application#what-are-the-requirements-for-an-application-to-be-tested mientras que su versión en español puede encontrarse como anexo este este documento.

==== 4.1.2 Requisitos no funcionales

Dado el carácter comparativo que posee el proyecto, nos centraremos en los requisitos de calidad de ejecución, a fin de optimizar lo máximo posible cada aplicación. Los requisitos no funcionales más relevantes en el proyecto serán:

- **Latencia**: Las aplicaciones deben ofrecer un tiempo de respuesta lo más bajo posible dentro de las características de la tecnología en la que se base.
- **Consumo de recursos**: Las aplicaciones deben hacer un uso responsable de los recursos del sistema (como son la memoria o el uso del procesador).
- **Escalabilidad**: en nuestro caso, será escalabilidad vertical, que buscará que nuestras aplicaciones no vean degradada su calidad (en este caso una baja latencia y consumo de recursos) ante grandes cargas de trabajo.
- **Concurrencia**: Las aplicaciones tienen que estar libres de interbloqueos y esperas innecesarias. Dada la naturaleza de la mayoría de tecnologías (reactivas y no bloqueantes), este requisito es fácilmente satisfacible.

=== 4.2. Diseño e Implementación

A continuación, se expondrá el diseño e implementación de cada aplicación construida, así como un acceso a su código fuente.

<<<

==== 4.2.1 Node.js

===== Código de la aplicación

https://github.com/Maes95/TFG-WebChat/tree/v2.1/NodeJS-WebChat

===== Diseño y arquitectura

La aplicación de Node.js es muy sencilla, consta de un servidor en Express que da soporte a un servidor WebSocket proporcionado por la librería ws.

El servidor WebSocket está orientado a eventos, al iniciarse una conexión, permite recoger los eventos que genera el cliente (representado mediante la variable ‘ws’)

[source,javascript]
---------------------------------------------------------------------
const wss = new SocketServer({ server });
wss.on('connection', (ws) => {
	ws.on('message', onMessageCallback );
  	ws.on('close', onCloseCallback )
});
---------------------------------------------------------------------

=====  Funcionamiento

[.underline]#Conexión#: El usuario queda registrado en la aplicación cuando establece la conexión. Su primer mensaje asigna su nombre y su chat a su conexión. En caso de que el usuario este duplicado, su conexión se cerrará.

[source,javascript]
---------------------------------------------------------------------
ws['chat'] = message['chat'];
ws['name'] = message['name'];
---------------------------------------------------------------------

Para asegurar la unicidad de los nombres de usuario, se utiliza un conjunto (Set en js).

[.underline]#Re-envío de mensajes#: Para resolver el re-envió de mensajes, el objeto wss tiene registrados todos los usuarios actualmente conectados, por lo que para re-enviar un mensaje solo es necesario recorrerlos y mandarlo en el caso de que el chat del emisor y del receptor sean el mismo:

[source,javascript]
---------------------------------------------------------------------
wss.clients.forEach( (client) => {
  if(client.chat == ws.chat) client.send(data)
});
---------------------------------------------------------------------

<<<

[.underline]#Desconexión#: La librería ws se encarga de borrar automáticamente la conexión con el cliente, por lo tanto, lo único que debemos hacer cuando un usuario se desconecta es borrar su nombre del conjunto.

=====  Problemas en el desarrollo

Debido al carácter reactivo de Node.js y las librerías de alto nivel, el desarrollo de esta aplicación se simplifica en gran medida, por lo que no dio lugar a problemas importantes.

Solo cabe señalar que, al igual que en otras tecnologías, se pensó en agrupar a los usuarios por salas para que el re-envío de mensajes fuera automático, pero aparte de complicar de forma considerable la aplicación, no ofrecía mejoras en su rendimiento, sino todo lo contrario, por lo que se descartó la refactorización en ese aspecto.

<<<

==== 4.2.2  Node.js con librería de clúster

===== Código de la aplicación

https://github.com/Maes95/TFG-WebChat/tree/v2.1/NodeJSCluster-WebChat

===== Diseño y arquitectura

En esta aplicación encontramos una evolución de la anterior. Esta variante pretende hacer un uso más eficiente de los núcleos de la máquina. Para ello hace uso de la librería cluster.

La arquitectura de la aplicación se hace más compleja. Sigue un modelo maestro-trabajador:

- Maestro: se encargar de la creación de los trabajadores y de las conexiones entre ellos.

- Trabajador: se ocupa de recibir los mensajes de los clientes.

Características de la versión con cluster:

- La comunicación entre ambos se realiza mediante paso de mensajes entre procesos.

- En este caso, será el maestro quien se ocupe de asegurar la unicidad de los nombres, también con un conjunto.

- Para maximizar el rendimiento, el número de trabajadores será igual al número de núcleos de la máquina en la que ejecuta

===== Funcionamiento

[.underline]#Conexión#: Todos los trabajadores tienen su propio servidor WebSocket, aunque escuchan del mismo puerto. Al conectarse un cliente, es asignado a un trabajador (y a su correspondiente servidor de WebSocket) mediante un algoritmo de Round Robin a fin de distribuir los usuarios de forma homogénea. Cuando el cliente manda su mensaje de conexión, su trabajador debe comunicárselo al maestro, que validará si el usuario ya existe y comunicará el resultado de vuelta a ese trabajador*. Al recibir la respuesta, el trabajador operará de la misma forma que la versión monolítica en función de la respuesta, añadiendo los atributos oportunos si el usuario no existe o cerrando la conexión en caso contrario.

*__El maestro añadirá el usuario en cualquier caso, ya que al tratarse de un conjunto, no admite duplicados.__

<<<

[.underline]#Re-envío de mensajes#: Cuando un trabajador recibe un mensaje de uno de sus clientes, lo re-envía al maestro para que este lo distribuya. Cada trabajador recibe el mensaje, que re-envía a sus clientes (si pertenecen a la misma sala que especifica el mensaje).

[source,javascript]
---------------------------------------------------------------------
// Trabajador enviando el mensaje al maestro
process.send({ type: "message", chat: ws.chat, message: data });

// Maestro re-enviando el mensaje a los trabajadores
for (var i in cluster.workers) cluster.workers[i].send(message);

// Trabajador re-enviando el mensaje del master a sus clientes
wss.clients.forEach( (client) => {
  if(client.chat == data.chat) client.send(data.message)
} );
---------------------------------------------------------------------

[.underline]#Desconexión#: Cuando un cliente se desconecta, el trabajador envía un mensaje al maestro para que borre de su registro el nombre de usuario.

===== Problemas en el desarrollo

Al desarrollar la aplicación, el primer reto fue comprender el comportamiento conjunto entre la librería cluster y los servidores Express y ws. Las librerías de servidores mencionadas están preparadas para trabajar como clúster tal y como se ha mencionado anteriormente, son capaces de repartir las peticiones de forma equitativa.

Otro problema en el desarrollo fue la comunicación, la cual se tornaba bastante más compleja que en su versión monolítica. El paso de mensajes entre procesos resolvía de forma contundente el renvío de mensajes entre trabajadores, pero la validación de la primera conexión del usuario requería un flujo algo más complejo. En un principio y partiendo de la aplicación monolítica, cada trabajador tenía su propio conjunto de nombres para validar la unicidad, pero el tener que comprobar un nombre en todos los trabajadores y esperar su respuesta resultaba demasiado complejo, por lo que se decidió que la gestión de nombres de usuario se llevaría a cabo en el maestro para simplificarlo.

El proyecto se desarrolló en la versión 4.2 de Node.js, siendo la comunicación entre maestro y trabajador complicada debido a que el maestro a priori, no podía saber que trabajador le había mandado un mensaje (impidiendo mandar un mensaje de vuelta, como es en el caso de la validación del usuario). Para resolver este problema, era necesario enviar a cada trabajador en su creación si id con el que el maestro le identificaba, pudiéndoselo mandar en el mensaje para poder ser identificado.  A partir de la versión 6 de Node<<https://nodejs.org/api/cluster.html#cluster_event_message_1>>, este problema quedaba solucionado, ya que se enviaba una referencia directa al trabajador junto al mensaje de forma automática.

<<<

==== 4.2.3  Akka

===== Código de la aplicación

https://github.com/Maes95/TFG-WebChat/tree/v2.1/AkkaPlay-WebChat

===== Diseño y arquitectura

La aplicación de Akka corresponde a una versión simplificada del proyecto anterior, la cual estaba pensada para funcionar en varias instancias como un clúster. La aplicación consta de tres tipos de actores:

- ChatManager, cuyo único cometido es la gestión de actores de tipo “Chat”. Proporciona (o crea) nuevos chats a petición de los usuarios. La aplicación cuenta con una única instancia de este actor. Esto es posible gracias a que Akka permite registrar actores en un contexto global:

[source,java]
---------------------------------------------------------------------
// Para crearlo en las clase de configuración
Akka.system().actorOf(Props.create(ChatManager.class), "ChatManager");
// Para usarlo en cualquier otra clase
Akka.system().actorFor("Akka://application/user/ChatManager");
---------------------------------------------------------------------

- Chat, encargado de gestionar a los usuarios de una sala concreta distribuyendo sus mensajes y permitiendo su suscripción/des-suscripción.
- User, encargado de recibir los mensajes del cliente mediante WebSocket, registrarse en una chat y re-enviar los mensajes que recibe al cliente. La creación de un User se realiza cuando un cliente abre una conexión WebSocket con la aplicación.

Esto es posible gracias a Play, que nos permite asignar un WebSocket a un actor tal y como se muestra en el siguiente método:

[source,java]
---------------------------------------------------------------------
public WebSocket<String> socket() {
    return WebSocket.withActor(User::props);
}
---------------------------------------------------------------------

Esto crea un nuevo User en el que se ha inyectado un atributo de tipo ActorRef (llamado out en la clase), que es una referencia a la conexión WebSocket y que podemos utilizar para mandar mensajes directamente.

[source,java]
---------------------------------------------------------------------
out.tell(((Message) message).getJson().toString(), self());
---------------------------------------------------------------------

La recepción de mensajes por parte del cliente se producirá como si fuera un mensaje de otro actor, a través del método [source]`onRecive(Object message)`

=====  Funcionamiento

[.underline]#Conexión#: Cuando un cliente abre la conexión, Play ejecuta el siguiente método:

[source,java]
---------------------------------------------------------------------
public WebSocket<String> socket() {
    return WebSocket.withActor(User::props);
}
public static Props props(ActorRef out) {
    return Props.create(User.class, out, Akka.system().actorFor("Akka://application/user/ChatManager"));
}
---------------------------------------------------------------------

Este método crea un nuevo User al que asigna la conexión WebSocket establecida. De esta forma, la nueva instancia podrá recibir mensajes del cliente mediante su método [source]`onRecive(Object message)` (como si lo estuviera enviando otro actor) y enviarle mensajes al cliente a partir de su atributo out, un ActorRef que representa al cliente.

El mensaje de conexión del cliente es recibido por su User, que manda un mensaje pidiendo suscribirse a una sala de chat al ChatManager. Si su nombre de usuario no existe, manda un mensaje de suscripción y queda registrado, en caso contrario, manda un mensaje a su cliente y se “suicida” para eliminarse del sistema.

[source,java]
---------------------------------------------------------------------
self().tell(PoisonPill.getInstance(), self());
---------------------------------------------------------------------

[.underline]#Re-envío de mensajes#: Como hemos mencionado, los mensajes del cliente llegan a través del método [source]`onRecive(Object message)` del Usuario y es re-enviado al actor que representa su sala de chat. El actor Chat re-envía este el mensaje a todos sus usuarios.

[source,java]
---------------------------------------------------------------------
users.entrySet().forEach((entry) -> {
      entry.getValue().tell(message, getSelf());
});
---------------------------------------------------------------------

[.underline]#Desconexión#: Cuando el usuario cierra la conexión WebSocket, se ejecuta el método postStop() del User correspondiente, que se encarga de dar de baja al usuario de su sala de chat.

[source,java]
---------------------------------------------------------------------
UnsubscribeChat unsubscribeChat = new UnsubscribeChat(username);

chat.tell(unsubscribeChat,getSelf());
---------------------------------------------------------------------

=====  Problemas en el desarrollo

Al tratarse de una aplicación heredada, fue necesario no solo una fase de aprendizaje de Akka y Play, sino de la arquitectura de la aplicación. La aplicación original pretendía resolver el mismo problema que el de este proyecto, pero en el contexto del escalado horizontal, no vertical. En un primer momento, se incluyó la aplicación sin modificar en la comparativa, pero tras observar su complejidad en código, se trabajó en su refactorización para simplificarla. Esta nueva versión monolítica resulto dar mejores resultados y es la que actualmente se encuentra dentro de la comparativa.

<<<

==== 4.2.4  Vert.x

===== Código de la aplicación

https://github.com/Maes95/TFG-WebChat/tree/v2.1/Vertx-WebChat

===== Diseño y arquitectura

La aplicación de Vert.x, al contrario de Akka y a pesar de estar basado en actores, prescinde de crear un actor para la sala de chat.

La aplicación se compone de:

- Un ChatManager, un Verticle que se ocupa de la recepción de mensajes por parte de los clientes, su posterior distribución y la gestión de los usuarios (creación y eliminación).

- Varios User, Verticles que representan a cada usuario de la aplicación, que se encargan de almacenar la conexión WebSocket con su cliente para enviarle mensajes.

=====  Funcionamiento

[.underline]#Conexión#: Cuando un usuario inicia la conexión WebSocket, al contrario de otras aplicaciones, no se realiza ninguna acción más que proporcionar un handler para los mensajes. Cuando el cliente manda el mensaje de conexión, si el nombre no existe, se crear un nuevo User y se incluye en la aplicación, deployeandolo, y guardando su id de Verticle en un mapa cuya clave es el nombre.

[source,java]
---------------------------------------------------------------------
vertx.deployVerticle(user, res -> {
    if (res.succeeded()) {
        //Save the deploymentID to later remove the verticle
        users.put(name, res.result());
    } else {
        System.err.println("Error at deploy User");
    }
});
---------------------------------------------------------------------

[.underline]#Re-envío de mensajes#: El chat manager es el encargado de recibir los mensajes de los clientes, publicándolos en el EventBus con la dirección igual a la sala de chat.

[source,java]
---------------------------------------------------------------------
vertx.eventBus().publish(message.getString("chat"), message);
---------------------------------------------------------------------

<<<

Por otro lado, cuando un User es deployeado, se suscribe a su chat para recibir los mensajes dirigidos a ese chat y re-enviar a su cliente dichos mensajes.

[source,java]
---------------------------------------------------------------------
vertx.eventBus().consumer(chat).handler( data -> {
    // Listen for messages from his chat
    try{
       // Try to send the message
        this.wss.writeFinalTextFrame(data.body().toString());
    }catch(IllegalStateException e){
        // The user is offline, so I delete it.
        vertx.eventBus().publish("delete.user", name);
        wss.close();
    }
});
---------------------------------------------------------------------

[.underline]#Desconexión#: Se produce cuando User no es capaz de enviar un mensaje a su cliente. Publica su borrado en el EventBus y cierra la conexión. El evento de borrado es capturado por el ChatManager, que da de baja al User.

[source,java]
---------------------------------------------------------------------
vertx.undeploy(users.get(user_name));
users.remove(user_name);
---------------------------------------------------------------------

=====  Problemas en el desarrollo

Al igual que Akka, está aplicación formaba parte de un proyecto anterior heredado, pero en este caso, dado que existía una nueva versión de la tecnología (Vertx 3) que no era compatible con la anterior junto con la complejidad de la aplicación al estar pensada para ser distribuida, se desarrolló de nuevo (tomando la estructura de la anterior).

El desarrollo de la aplicación fue sencillo. Gracias al EventBus, la comunicación entre Verticles (actores en Vertx) resulta menos enrevesada que con Akka y no requiere de clases para definir los distintos tipos de mensajes.

Por otro lado, si requirió un estudio de la tecnología para poder optimizar la aplicación: entender el modelo de concurrencia, los ciclos de vida de los Verticles y el funcionamiento del EventBus.

Al igual que la aplicación de Akka, se desarrolló una versión en la que los User tomaban el control total de la conexión WebSocket (no solo la escritura). Esta versión resulto ser más compleja a la hora de gestionar los Verticles y no ofrecía mejores resultados, por lo que fue descartada.

<<<

==== 4.2.5  Vert.x sin EventBus

===== Código de la aplicación

https://github.com/Maes95/TFG-WebChat/tree/master/VertxNoEventbus-WebChat

===== Diseño y arquitectura

Esta aplicación pretende comprobar cómo afecta el EventBus a la aplicación anterior, eliminándolo y sustituyéndolo por llamadas directas. Esto da lugar a los siguientes cambios:

- Las salas de chat, en lugar de ser una dirección del bus, son agrupadas en un mapa, donde el nombre de la sala es la clave y un mapa de Users es el valor.

- Las instancias de User dejan de ser Verticles (no requiere escuchar eventos de forma asíncrona), por lo que no es necesario incluirlos en el contexto de la aplicación.

- Las instancias de User deben conocer a su ChatManager.

=====  Funcionamiento

[.underline]#Conexión#: Al igual que la aplicación anterior, cuando se abre la conexión, se registra un handler para recoger los mensajes del usuario. Cuando el usuario manda su mensaje de conexión, se comprueba que no exista, se crea un nuevo User y se añade al mapa correspondiente a su sala de chat (el mapa de la sala se crea si no existe).

[.underline]#Re-envío de mensajes#: Para comunicar los mensajes a otros clientes, User implementa el método send, que corresponde al handler del evento bajo la dirección de su chat.

De esta forma, cuando llega un mensaje, se distribuye a todos los usuarios con la misma sala de chat aprovechando la estructura de datos creada.
[source,java]
---------------------------------------------------------------------
rooms.get(message.getString("chat")).values().forEach((user)->{
                         user.send(message);
});
---------------------------------------------------------------------

[.underline]#Desconexión#: Al igual que la anterior aplicación, se produce cuando User no es capaz de mandar un mensaje a su cliente, llamando explícitamente al ChatManager para que elimine al User del mapa correspondiente a su sala de chat.

<<<

==== 4.2.6  SpringBoot con servidor Tomcat

===== Código de la aplicación

https://github.com/Maes95/TFG-WebChat/tree/v2.1/SpringBoot-Tomcat-WebChat

===== Diseño y arquitectura

La aplicación hace uso de la anotación [source]`@ServerEndpoint` sobre la clase ChatManager, que convierte a dicha clase en un punto de entrada para la conexión WebSocket. Permite a la clase implementar métodos bajo las anotaciones:

- [source]`@OnOpen` : Se ejecuta cuando el usuario establece la conexión

- [source]`@OnMessage` : Se ejecuta cada vez que el usuario manda un mensaje

- [source]`@OnClose` : Se ejecuta cuando la conexión WebSocket se cierra

- [source]`@OnError` : Se ejecuta cada vez que sucede un error en la conexión, capturándolo

Estas anotaciones permiten tener un control sencillo del flujo de la aplicación y de los eventos que requiere.

Cada vez que un cliente se conecta, se crea una instancia de ChatManager que se encargará de recoger los eventos de ese usuario en concreto. Esto es posible gracias a SpringBoot, que se encarga de servir esta clase como un componente reutilizable bajo la anotación [source]`@Bean` en WebChatSpringBootApplication (que actúa como archivo de configuración):

[source,java]
---------------------------------------------------------------------
@Bean
public ChatManager reverseWebSocketEndpoint() {
	return new ChatManager();
}
---------------------------------------------------------------------

La información concreta del usuario se guarda en una clase User, de forma que cada ChatManager tiene un parámetro de tipo User.

La estructura del almacenamiento de usuarios es un mapa cuya clave es el nombre de la sala y cuyo valor es otro mapa que almacena los usuarios, siendo su clave única, su nombre.

<<<

=====  Funcionamiento

[.underline]#Conexión#: La conexión corresponde a la anotación [source]`@OnOpen`, cuyo método crea un nuevo objeto usuario con la sesión creada a partir de la conexión WebSocket realizada. El mensaje de conexión, en cambio, es capturado por el método bajo la anotación [source]`@OnMessage`, que tras validad que el usuario asociado a esa sesión no tiene aún atributos como “name” o “chat”, comprueba que el nombre sea único y se los asigna. Además, el usuario es guardado en el mapa correspondiente a su sala de chat
[source,java]
---------------------------------------------------------------------
private static final Map<String, Map<String, User>> rooms = new HashMap<>();
---------------------------------------------------------------------

[.underline]#Re-envío de mensajes#: Los mensajes son capturados por el método bajo la anotación [source]`@OnMessage`. Si el User es válido (tiene ya su nombre y sala de chat declarados) el mensaje es reenviado a todos los usuarios de la sala de chat a la que pertenece el usuario, guardados en el mapa de la sala correspondiente

[source,java]
---------------------------------------------------------------------
// Broadcast message
rooms.get(user.getChat()).values().forEach( _user ->
    _user.send(message)
);
---------------------------------------------------------------------

El usuario concreto envía el mensaje correspondiente a través de su sesión:

[source,java]
---------------------------------------------------------------------
this.session.getBasicRemote().sendText(message);
---------------------------------------------------------------------

[.underline]#Desconexión#: La desconexión se captura en el método bajo la anotación [source]`@OnClose`, que se ocupa de borrar al usuario desconectado de su sala.

=====  Problemas en el desarrollo

Las anotaciones y la configuración de SpringBoot nos permite un desarrollo rápido gracias a la estructura que nos proporciona, pero al contrario que Akka y Vertx, la concurrencia es un problema a solucionar por el desarrollador. Uno de los primeros problemas que nos encontramos en el desarrollo era el acceso concurrente al contenedor de salas y usuarios, solucionado mediante el uso de mapas concurrentes, concretamente, ConcurrentHashMap.

<<<

Otro problema encontrado era que el recurso encargado de enviar mensajes mediante WebSocket debía estar en exclusión mutua, no permitía la escritura concurrente (no cuenta con ningún buzón o cola de mensajes que permita la concurrencia). Para resolverlo, se encapsulo esta acción en un método sincronizado, asegurando así la exclusión mutua.

[source,java]
---------------------------------------------------------------------
public synchronized void send(String message){
      try {
              this.session.getBasicRemote().sendText(message);
      } catch (IOException e) {
              e.printStackTrace();
      }
}
---------------------------------------------------------------------
Se probaron diferentes implementaciones (Como usar la clase bajo [source]`@ServerEndpoint` como un usuario y externalizar el ChatManager como un servicio), pero esto no solo complicaba el flujo de la aplicación, si no que aumentaba de forma considerable los tiempos de respuesta. Tras muchas iteraciones, la aplicación que forma parte de la comparativa es la descrita.

<<<

==== 4.2.7  SpringBoot con servidor Jetty

===== Código de la aplicación

https://github.com/Maes95/TFG-WebChat/tree/v2.1/SpringBoot-Jetty-WebChat

Esta aplicación corresponde a una versión idéntica a la anterior, usando como servidor Jetty en lugar de Tomcat. La única diferencia entre ambos reside en el archivo de configuración pom.xml:

[source,xml]
---------------------------------------------------------------------
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-websocket</artifactId>
	<exclusions>
		<exclusion>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-tomcat</artifactId>
		</exclusion>
	</exclusions>
</dependency>
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-jetty</artifactId>
</dependency>
---------------------------------------------------------------------

Dónde se excluye el servidor configurado por defecto (Tomcat) para usar el de Jetty.

El objetivo de esta aplicación es ver la diferencia entre una misma aplicación en SpringBoot con distintos servidores.


<<<

=== 4.3. Pruebas

Las aplicaciones desarrolladas carecen de pruebas unitarias o de integración propias, comparten un cliente común capaz de probarlas de forma completa.

A lo largo de este apartado hablaremos de este cliente, su implementación y de sus características.

La implementación del cliente puede encontrarse en https://github.com/Maes95/TFG-WebChat/tree/v2.1/WebChatTest

==== 4.3.1 Desarrollo e implementación

Como hemos comentado anteriormente, el cliente forma parte de un proyecto heredado al que intentamos dar continuación. La versión original del cliente permitía (dados unos parámetros escritos directamente en el código) probar una aplicación con los requisitos ya mencionados. Concretamente:

1. Genera X clientes para 1 sala de chat, de forma que cada cliente enviaba (además de su mensaje de conexión) 500 mensajes al resto de usuarios en un periodo de 5 segundos.

2. El mensaje contiene el momento (en milisegundos) en el que es enviado el mensaje. Cada cliente va recibiendo los mensajes y almacenando el tiempo que tardan en llegar (momento actual – momento que trae el mensaje).

3. Cuando todos los clientes han recibido todos los mensajes (sin pérdidas) se divide el tiempo total entre el número total de mensajes (Nº usuarios x Nº usuarios x 500) y se muestra por pantalla y se guarda en un archivo.

Estos pasos se repiten hasta 10 veces para obtener mayor homogeneidad. Al terminar todas las iteraciones, se lee el archivo y se calcula el tiempo medio de los intentos para hallar el tiempo de respuesta de la aplicación.

Este cliente hace uso de la librería de testing de Vertx, que dispone de múltiples herramientas para facilitar el desarrollo de pruebas para aplicaciones asíncronas.

Aunque funcional, queda limitado a un solo caso (X usuarios en una única sala de chat). Dentro de los objetivos de nuestro proyecto se encuentra el de ampliar este cliente de pruebas. Para ello, las nuevas funcionalidades a implementar son las siguientes:

- Automatización de pruebas, de forma que dadas unas aplicaciones y parámetros (como el número de usuarios y de salas de chat) en un archivo, nuestro cliente pueda ejecutar las pruebas sin que tengamos que interactuar.

- Añadir nuevas métricas, en concreto, el consumo de recursos de la máquina: uso de CPU y uso de memoria.

- Ofrecer una interfaz web que genere gráficas dinámicas para realizar la comparativa a partir de los resultados obtenidos.

A continuación, explicaremos como han sido desarrolladas estas nuevas funcionalidades

===== Automatización de pruebas

El primer paso para la automatización fue permitir que una aplicación pudiese ser probada con distintos número de usuarios y salas de chat. Dado que ya iterábamos por métodos, el siguiente paso era iterar por clases. Para abordar este concepto, usamos la anotación @Parameterized<< https://github.com/junit-team/junit4/wiki/parameterized-tests>> sobre nuestra clase de pruebas. Esta anotación nos permite definir un método bajo la anotación @Parameters, que nos permite devolver una colección de listas de objetos. Cada lista de objetos corresponde a los parámetros que recibirá el constructor de la clase. De esta forma, nuestro clase de pruebas se instanciará tantas veces como listas de parámetros proporcionemos.

Un ejemplo simple de este caso sería:

[source,java]
---------------------------------------------------------------------
@Parameters
public static Collection<Object[]> data() {
    return Arrays.asList(new Object[][] {
        { 10, 1 }, { 20, 1 }, { 30, 1 }
    });
}

public ChatTest(int usersPerChat, int numChats){ … }
---------------------------------------------------------------------

Donde el número de usuarios sería el primer parámetro y el número de salas el segundo.

El segundo paso, y uno de los más laboriosos, fue automatizar el despliegue de las aplicaciones, de forma que el cliente de pruebas gestionase los ciclos de vida de los procesos de cada aplicación. El objetivo es que se pudiera incluir varias aplicaciones que pasasen las pruebas con la configuración mencionada en el anterior párrafo, incluyéndolas como configuración.


[source,java]
---------------------------------------------------------------------
return Arrays.asList(new Object[][] { { 40, 1, "Node" } });
---------------------------------------------------------------------

Para lanzar una aplicación, se genero un archivo ejecutable.sh en el directorio de cada aplicación, de forma que bastaba con ejecutarlo desde Java para poder controlar el proceso

[source,java]
---------------------------------------------------------------------
switch(app){
   case "Node": Process process = new ProcessBuilder("./run.sh")
                .directory(new File(path+ "WebChatNodeWebsockets"))
                .start();
       break;
   …
}
---------------------------------------------------------------------

Llegado este punto y para hacer la aplicación más flexible y que los cambios de configuración no dependiesen de manipular el código fuente, se decidió crear un archivo de configuración que pudiese ser leído por la aplicación. El formato elegido fue JSON. El archivo de configuración era originalmente como se muestra a continuación.

[source,json]
---------------------------------------------------------------------
{
    "apps" : ["AkkaPlay", "NodeJS"],
    "chats": [
        {
            "numChats": 1,
            "users": [10, 20, 30, 40, 50, 60]
        },
        {
            "numChats": 2,
            "users": [20, 25, 30, 35]
        },
        {
            "numChats": 4,
            "users": [10, 12, 15, 17]
        }
    ]
}
---------------------------------------------------------------------

Para conseguir una mayor modularidad y poder extender el código, se encapsulo toda la lógica referente al manejo del proceso de la aplicación en una clase concreta, WebChatApp. Esta idea se desarrolló hasta hacer de WebChatApp una interfaz utilizada por ChatTest para la gestión de la aplicación, permitiendo desarrollar clases que permitan distintos tipos de configuración que implementasen dicha interfaz. La estructura de clases resultantes fue la siguiente:

image::./classes.png[classes]

Pretendemos distinguir entre dos tipos de aplicaciones:

- *Lanzables* (WebChatThrowableApp): Son las aplicaciones que queremos que sean 100% gestionadas por la clase de pruebas.

- *No Lanzables* (WebChatNonThrowableApp): Debido a que no siempre puede lanzarse una aplicación (ya sea por su forma de lanzarse o porque se encuentra en otra máquina), creamos esta categoría que se traduce al código en forma de una clase abstracta. Las implementaciones concretas se distinguen entre sí únicamente por la obtención de métricas adicionales (como ya veremos más adelante).

- *Locales* (WebChatLocalApp): Aplicación ya lanzada en la misma máquina. Para su gestión, proporcionamos en la configuración su PID.

- *Remotas* (WebChatRemoteApp):  Aplicación lanzada en una máquina remota.

Nuestra aplicación de pruebas hace uso de la clase WebChatAppFactory, que nos proporciona un objeto WebChatApp con la implementación adecuada en función de la configuración introducida. La estructura del archivo de configuración se extiende, permitiendo configurar cada app de forma independiente. El formato utilizado puede encontrarse en la documentación en GitHub (en Inglés) o en el anexo X de este documento (en Español).

<<<

===== Nuevas métricas

Una vez tenemos una sólida estructura para manejar las aplicaciones, tenemos mayor facilidad para obtener las métricas de los procesos de las mismas. Como hemos comentado, las métricas deseadas son la cantidad de memoria consumida y el uso de CPU. Para su obtención, hemos hecho uso del comando top de Linux, concretamente:

[source]
---------------------------------------------------------------------
top -b -n 1 –p PID
---------------------------------------------------------------------

Este comando, ejecutado desde java mediante un ProcessBuilder (al igual que una aplicación) y proporcionando el PID del proceso nos devuelve una lista de líneas. En las dos últimas podemos ver toda la información del proceso de la aplicación de chat concreta:

[source]
---------------------------------------------------------------------
PID USUARIO PR  NI    VIRT    RES    SHR S  %CPU %MEM   HORA+ ORDEN
3121 michel  20   0  885276  33896  18568 S   0,0  0,6 0:00.22 node
---------------------------------------------------------------------

Aunque solo necesitamos la cantidad de memoria RAM utilizada (RES) y el uso de la CPU (%CPU), hemos decidido tomar además el uso de memoria como porcentaje (%MEM) y la memoria virtual (VIRT).

===== Interfaz Web

Hasta ahora, todos los resultados son mostrados por la terminal, por lo que publicar los resultados en otros formatos puede ser tedioso.

Para ofrecer una mejor experiencia y poder realizar la comparativa de forma más eficaz, se ha desarrollado un servidor simple que ofrece un cliente HTML.

- *Servidor*: Se trata de un servidor desarrollado en Vert.x (por su sencillo y eficaz desarrollo) el cual hace uso del patrón Singleton << https://msdn.microsoft.com/es-es/library/bb972272.aspx>> para garantizar una única instancia durante la ejecución y facilitar el acceso a la misma. Se encarga de publicar los resultados al cliente, haciendo de nexo entre ChatTest y el cliente. La comunicación entre Cliente y Servidor se realiza mediante el EventBus de Vertx, que permite extender la publicación eventos al lado Cliente (en JavaScript) que cuenta con su propia referencia al EventBus. Utiliza WebSockets para soportar la comunicación.

[source,java]
---------------------------------------------------------------------
public void send(JsonObject result){
    vertx.eventBus().publish("new.result", result);
}
---------------------------------------------------------------------

- **Cliente**: Se trata de una aplicación SPA desarrollada en AngularJS que muestra los resultados del cliente en graficas dinámicas, junto a las tablas de los resultados que muestra. Para generar los gráficos se ha utilizado la libreria Chart.js <<http://www.chartjs.org/>>, concretamente su versión para AngularJS <<http://jtblin.github.io/angular-chart.js/>>.

<<<

==== 4.3.2 Funcionamiento

El flujo de funcionamiento de la aplicación puede apreciarse en la siguiente imagen:

image::./TestSystem.png[TestSystem]

- *Paso 1*: Se lanza la aplicación de Test tomando un archivo de configuración. Se lanza (de forma automática) TestResultServer, que abre una nueva ventana en el navegador con el cliente web escuchando, a la espera de resultados. Se realizan las pruebas.

- *Paso 2*: ChatTest pregunta por la métricas a WebChatApp

[source,java]
---------------------------------------------------------------------
current_application.getMetrics();
---------------------------------------------------------------------

- *Paso 3*: WebChatApp pregunta por sus métricas a TestMetrics

[source,java]
---------------------------------------------------------------------
@Override
public Metrics getMetrics() {
    return TestMetrics.getMetricsTop(pid);
}
---------------------------------------------------------------------

- *Paso 4*: TestMetrics resuelve la lectura de métricas y las encapsula en un Objeto Metrics a WebChatApp

- *Paso 5*: WebChatApp devuelve a su vez este objeto a ChatTest, que añade a un objeto de tipo Result. Este objeto se crea para cada prueba, guardando todas las métricas y la configuración de la prueba (Nº de chats, Nº de clientes y el nombre de la aplicación probada).

- *Paso 6*: Al terminar una prueba, ChatTest enviar el Result (ya en formato JSON) a TestResultServer. Al haber múltiples métricas almacenadas (diferentes tiempos de respuesta debido a las 10 iteraciones) y diferente consumo de recursos (ya que se generan cada segundo). Al convertirse a JSON, se toma solo la media aritmética de cada métrica.

- *Paso 7*: TestResultServer publica el resultado en el EventBus, de forma que el cliente es capaz de recibirlo y añadirlo a su gráfica correspondiente.

image::./captura1.png[Captura 1]

* Los pasos 2-7 se repiten para cada tupla (Aplicación, Nº de chats, Nº de clientes)

* La obtención de métricas de latencia y consumo de recursos se realizan de forma concurrente.

== 5. Conclusiones y trabajos futuros

Reflexión sobre el trabajo realizado, qué objetivos se han cumplido y qué aspectos quedan pendientes para una futura ampliación del proyecto. Además se deben incluir unas conclusiones personales indicando lo que ha supuesto para el alumno la realización del trabajo. Entre 2 y 5 páginas.

== Bibliografía

:bibliography:

== Anexos

=== Anexo 1: Cómo construir una aplicación

La aplicación en cuestión debe poder soportar un chat en el que varios usuarios puedan comunicarse entre si.

Requiere lanzar la aplicación como un servidor que escuche de un puerto concreto y ofrecer una conexión WebSocket sobre la dirección '/chat'.

==== Primera conexión

El cliente, al establecer la conexión enviará sus datos en un string, que podrá formatearse a JSON y tiene la siguiente estructura:

[source,json]
---------------------------------------------------------------------
{
  "name": "MyName",
  "chat": "MyRoom"
}
---------------------------------------------------------------------

La aplicación debe almacenar estos datos junto a la conexión WebSocket, de forma que queden "registrados".

==== Gestión de mensajes

Una vez se ha establecido la conexión y se ha mandado el mensaje de inicialización, el cliente enviará mensajes a la aplicación, de nuevo como un String, que se podrá formatear a un JSON con la siguiente estructura:

[source,json]
---------------------------------------------------------------------
{
  "name": "MyName",
  "chat": "MyRoom",
  "message":"MyMessage"
}
---------------------------------------------------------------------

Este mensaje debe ser reenviado por la aplicación a todos los usuarios cuya sala de chat sea la misma que la del mensaje.

NOTE: No debe confundirse un mensaje de chat con un mensaje de conexión, la forma de diferenciarlos es por la existencia o no de la clave "message" en el JSON.

==== Desconexión

La aplicación debe gestionar la desconexión de usuarios, de forma que cuando un usuario se desconecta, este debe eliminarse de la aplicación para que no se le reenvíen mensajes.

==== Opcionales

Aunque las pruebas que se realizan no lo requieren, la aplicación puede impedir que dos usuarios con el mismo nombre puedan conectarse (independientemente del chat al que pertenezcan). En caso de que ya exista el usuario debería enviar un mensaje de vuelta al cliente tal y cómo se muestra a continuación:

[source,json]
---------------------------------------------------------------------
{
   "type": "system",
   "message": "A user with that name already exists"
}
---------------------------------------------------------------------

Además, y de cara a probar rápidamente el correcto funcionamiento de la aplicación, puede ofrecerse un cliente http que permita realizar la conexión desde el navegador.

<<<

=== Anexo 2: Cómo incluir una aplicación en la comparativa

WebChatTest contiene un archivo de configuración disponible en WebChatTest/src/main/resources/config.json con el siguiente aspecto:

[source,json]
---------------------------------------------------------------------
{
    "apps" : [
        {
            "name" : "NodeJS",
            "commands" : "node app.js",
            "port" : 8080,
        },
        {
            "name" : "Vert.x",
            "address" : "192.168.1.45",
            "port" : 5000,
        }
    ],
    "chats": [
        {
            "numChats": 1,
            "users": [10, 20, 30, 40, 50, 60]
        }
    ]
}
---------------------------------------------------------------------

Nuestra aplicación se incluirá como un nuevo objeto a "apps", cuyo formato se define en la siguiente tabla:


[options="header"]
|==========================
| Propiedad   | Tipo      | Obligatorio    | Por defecto       | Explicación
| name       | String     |     Si      |      -         | Nombre de la aplicación
| globalDefinition | String     |     No      |  Sin definición    | Definición de la tecnología
| specificDefinition | String     |     No      |      -         | Definición específica de la aplicación
| commands   | String     |     No      |      -         | Comando(s) que lanzan la aplicación
| port       | Number     |     No      |    9000        | Puerto en el que escucha la aplicación
| folderName | String     |     No      | name+"-WebChat"| Nombre de la carpeta donde se encuentra la aplicación
| address    | String     |     No      |  127.0.0.0     | Dirección IP del host de la aplicación
| delay      | Number     |     No      |   10000        | Tiempo (en ms) que se espera a que arranque la aplicación
| remote     | Boolean    |     No      |  false         | Indica si la máquina corre en remoto
| pid        | Number     |     No      |      -         | PID del proceso
|==========================

==== Aplicaciones locales

Son las aplicaciones lanzadas por `WebChatTest`

- El proyecto de la aplicación debe encontrarse en el mismo directorio que la aplicación que realiza las pruebas, WebChatTest.

- *Es obligatorio* especificar los comandos de arranque de la aplicación.

- No debe sobrescribirse la dirección.

==== Aplicaciones remotas

Son las aplicaciones NO lanzadas por `WebChatTest`

- *Es obligatorio* que especifique el parámetro `remote` a true.

- *Es obligatorio* que especifique la dirección dónde se ejecuta, a no ser que corra en la misma máquina.

- No es necesario, por tanto, especificar los comandos de arranque ni la carpeta de la aplicación. El retraso es fijo para las aplicaciones remotas (0 ms).

- Si la aplicación corre en la misma máquina y se quieren obtener las medidas de rendimiento, es necesario incluir en la configuración su `pid`
